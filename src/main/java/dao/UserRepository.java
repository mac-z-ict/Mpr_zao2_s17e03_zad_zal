package dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.function.Consumer;

import dao.mappers.IMapResultSetToEntity;
import dao.uow.IUnitOfWork;
import domain.RolesPermissions;
import domain.User;
import domain.UserRoles;

public class UserRepository extends RepositoryBase<User> implements IUserRepository {
//repozytorium dla userow - i ich uprawnien	
	
	
// nazwy tabel dla users roles permissions i tabel posredniczacych	
	public static final String TABLE_NAME = "t_sys_users";
	private static final String PERMISSIONS_TABLE_NAME = "t_sys_permissions";
	private static final String ROLES_TABLE_NAME = "t_sys_roles";
	private static final String USER_ROLES_TABLE = "UserRoles";
	private static final String ROLE_PERMISSIONS_TABLE = "RolesPermissions";
	
	private PreparedStatement setupPermissions;
	
	private IMapResultSetToEntity<UserRoles> userRolesMapper;
	private IMapResultSetToEntity<RolesPermissions> rolesPermissionsMapper;
	//ponizej zapytania - queries
	//Create query
	private static final String CREATE_TABLE_QUERY = "CREATE TABLE "+TABLE_NAME+"("
			+ "id bigint GENERATED BY DEFAULT AS IDENTITY,"
			+ "login VARCHAR(32),"
			+ "password VARCHAR(255)"
			+ ")";
	
	//insert query
	private static final String INSERT_QUERY = "INSERT INTO "+TABLE_NAME+"(login, password) VALUES (?, ?)";
	//update query
	private static final String UPDATE_QUERY = "UPDATE "+TABLE_NAME+" SET login = ?, password = ? WHERE id = ?";
	
	//tworzenie tabel
	private static final String USER_ROLES_CREATE_TABLE_QUERY = "CREATE TABLE UserRoles("
			+ "id bigint GENERATED BY DEFAULT AS IDENTITY,"
			+ "userId bigint,"
			+ "roleId bigint"
			+ ")";
	//tworzenie tabeli rola <- zawarte permissions
	private static final String ROLES_PERMISSIONS_CREATE_TABLE_QUERY = "CREATE TABLE RolesPermissions("
			+ "id bigint GENERATED BY DEFAULT AS IDENTITY,"
			+ "roleId bigint,"
			+ "permissionId bigint"
			+ ")";
	//select dla danego usera uprawnien
	private static final String SETUP_PERMISSIONS_QUERY = "SELECT RP.* FROM "+USER_ROLES_TABLE+" UR "
			+ "INNER JOIN "+ROLE_PERMISSIONS_TABLE+" RP ON (UR.roleId = RP.roleId)"
//			+ "INNER JOIN "+PERMISSIONS_TABLE_NAME+" P ON (RP.permissionId = P.id)"
			+ "WHERE UR.userId = ?";
	//tworzenie tabeli permissions
	private static final String T_SYS_PERMISSIONS_CREATE_TABLE = "CREATE TABLE "+PERMISSIONS_TABLE_NAME+"("
			+ "id bigint GENERATED BY DEFAULT AS IDENTITY,"
			+ "name VARCHAR(255)"
			+ ")";
	//tworzenie tabeli rol
	private static final String T_SYS_ROLES_CREATE_TABLE = "CREATE TABLE "+ROLES_TABLE_NAME+"("
			+ "id bigint GENERATED BY DEFAULT AS IDENTITY,"
			+ "name VARCHAR(255)"
			+ ")";
	//faktyczne utworzenie table na podstawie powyzszych queries 
	public UserRepository(Connection connection, IMapResultSetToEntity<User> mapper, IMapResultSetToEntity<UserRoles> userRolesMapper, IMapResultSetToEntity<RolesPermissions> rolesPermissionsMapper, IUnitOfWork uow) {
		super(connection, mapper, uow);
		try {
			createTable(USER_ROLES_TABLE, USER_ROLES_CREATE_TABLE_QUERY);
			createTable(ROLE_PERMISSIONS_TABLE, ROLES_PERMISSIONS_CREATE_TABLE_QUERY);
			createTable(PERMISSIONS_TABLE_NAME, T_SYS_PERMISSIONS_CREATE_TABLE);
			createTable(ROLES_TABLE_NAME, T_SYS_ROLES_CREATE_TABLE);
			
			setupPermissions = connection.prepareStatement(SETUP_PERMISSIONS_QUERY);
			this.userRolesMapper = userRolesMapper;
			this.rolesPermissionsMapper = rolesPermissionsMapper;
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
	//pobor do resut setu tabel w celu wyszukania nas interesujacej
	private void createTable(String tableName, String createTableQuery) throws SQLException {
		ResultSet rs = connection.getMetaData().getTables(null, null, null, null);
		boolean tableExists = false;
		while (rs.next()) {
			System.out.println("Processing: "+ rs.getString("TABLE_NAME"));
			if (tableName.equalsIgnoreCase(rs.getString("TABLE_NAME"))) {
				tableExists = true;
				break;
			}
		}
		
		System.out.println("Table: "+tableName+" | Found: "+ tableExists);
		
		if (!tableExists)
			connection.createStatement().executeUpdate(createTableQuery);
	}

	@Override
	protected void setUpdateQuery(User p) throws SQLException {
		update.setString(1, p.getLogin());
		update.setString(2, p.getPassword());
		update.setInt(3, p.getId());
	}

	@Override
	protected void setInsertQuery(User p) throws SQLException {
		insert.setString(1, p.getLogin());
		insert.setString(2, p.getPassword());
	}

	@Override
	protected String tableName() {
		return TABLE_NAME;
	}

	@Override
	protected String createTableSql() {
		return CREATE_TABLE_QUERY;
	}

	@Override
	protected String insertSql() {
		return INSERT_QUERY;
	}

	@Override
	protected String updateSql() {
		return UPDATE_QUERY;
	}

	@Override
	public User withLogin(String login) {
		//@formatter:off
		return getAll()
				.stream()
				.filter(u -> login.equals(u.getLogin()))
				.findFirst()
				.orElse(null);
		//@formatter:on
	}

	@Override
	public User withLoginAndPassword(String login, String password) {
		//@formatter:off
		return getAll()
		//lista userow zwrot z rs		
				.stream()
		//strumien i porownanie kazdego elementu
			// jak wynik true element kolekcji pozostaje
				.filter(u -> login.equals(u.getLogin()) && password.equals(u.getPassword()))
				.findFirst()
				.orElse(null);
		//@formatter:on
	}

//wstawienie dla odpowiedniego usera danych permissions 
	@Override
	public void setupPermissions(User user) {
		try {
			Set<RolesPermissions> permissions = new HashSet<>();
			
			setupPermissions.setInt(1, user.getId());
			ResultSet rs = setupPermissions.executeQuery();
			while(rs.next()) {
				permissions.add(rolesPermissionsMapper.map(rs));
			}
			user.setRolesPermissions(permissions);
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

}
